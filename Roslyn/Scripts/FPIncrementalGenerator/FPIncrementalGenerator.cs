using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Runtime.CompilerServices;

#pragma warning disable RS1038
#pragma warning disable RS1041
#pragma warning disable CS8602
#pragma warning disable CS8604
#pragma warning disable CS8605

// ReSharper disable ALL

namespace Herta.Generators
{
    [Generator(LanguageNames.CSharp)]
    internal sealed class FPIncrementalGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            IncrementalValuesProvider<ClassDeclarationSyntax> provider = context.SyntaxProvider.CreateSyntaxProvider(predicate: static (s, _) => s is ClassDeclarationSyntax, transform: static (ctx, _) => GetTargetClass(ctx)).Where(static m => m != null)!;
            IncrementalValueProvider<(Compilation Left, ImmutableArray<ClassDeclarationSyntax> Right)> compilationAndClasses = context.CompilationProvider.Combine(provider.Collect());
            context.RegisterSourceOutput(compilationAndClasses, static (spc, source) =>
            {
                (Compilation compilation, ImmutableArray<ClassDeclarationSyntax> classList) = source;
                foreach (ClassDeclarationSyntax? classDecl in classList)
                    GenerateCode(spc, compilation, classDecl);
            });
        }

        private static ClassDeclarationSyntax? GetTargetClass(GeneratorSyntaxContext context)
        {
            ClassDeclarationSyntax classDeclaration = (ClassDeclarationSyntax)context.Node;
            if (!classDeclaration.Modifiers.Any(SyntaxKind.StaticKeyword) || !classDeclaration.Modifiers.Any(SyntaxKind.PartialKeyword))
                return null;

            SemanticModel semanticModel = context.SemanticModel;

            foreach (AttributeListSyntax attrList in classDeclaration.AttributeLists)
            {
                foreach (AttributeSyntax attr in attrList.Attributes)
                {
                    TypeInfo typeInfo = semanticModel.GetTypeInfo(attr);
                    ITypeSymbol? attributeType = typeInfo.Type;

                    if (attributeType is null)
                        continue;

                    if (attributeType.ToDisplayString() == "Herta.FPGeneratorAttribute" && attributeType.ContainingAssembly?.Name == "FP")
                        return classDeclaration;
                }
            }

            return null;
        }

        private static void GenerateCode(SourceProductionContext context, Compilation compilation, ClassDeclarationSyntax classDeclaration)
        {
            SemanticModel semanticModel = compilation.GetSemanticModel(classDeclaration.SyntaxTree);
            string? namespaceName = classDeclaration.FirstAncestorOrSelf<NamespaceDeclarationSyntax>()?.Name.ToString();
            string className = classDeclaration.Identifier.Text;
            StringBuilder sb = new StringBuilder();
            sb.AppendLine("// <auto-generated>");
            sb.AppendLine();
            sb.AppendLine("using Herta;");
            sb.AppendLine();

            string? tab = null;
            if (!string.IsNullOrWhiteSpace(namespaceName))
            {
                tab = "\t";
                sb.AppendLine($"namespace {namespaceName}");
                sb.AppendLine("{");
            }

            sb.AppendLine($"{tab}public static partial class {className}");
            sb.AppendLine($"{tab}{{");

            foreach (FieldDeclarationSyntax? member in classDeclaration.Members.OfType<FieldDeclarationSyntax>())
            {
                if (!member.Modifiers.Any(SyntaxKind.ConstKeyword) || !member.Modifiers.Any(SyntaxKind.PrivateKeyword))
                    continue;

                foreach (VariableDeclaratorSyntax variable in member.Declaration.Variables)
                {
                    if (semanticModel.GetDeclaredSymbol(variable) is not IFieldSymbol symbol || symbol.ConstantValue is null)
                        continue;

                    long raw;
                    switch (symbol.Type.SpecialType)
                    {
                        case SpecialType.System_Single:
                            raw = FloatToRaw((float)symbol.ConstantValue);
                            break;
                        case SpecialType.System_Double:
                            raw = DoubleToRaw((double)symbol.ConstantValue);
                            break;
                        default:
                            continue;
                    }

                    string name = $"_{variable.Identifier.Text}";
                    sb.AppendLine($"{tab}\tpublic static readonly FP {name} = FP.FromRaw({raw}L);");
                }
            }

            if (tab != null)
            {
                sb.AppendLine($"{tab}}}");
                sb.Append("}");
            }
            else
            {
                sb.Append($"{tab}}}");
            }

            context.AddSource($"{namespaceName}{(namespaceName != null ? "." : null)}{className}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
        }

        private static long FloatToRaw(float value)
        {
            const int Q16_SHIFT = 16; // 16 fractional bits (Q48.16 format)
            const int FLOAT_MANTISSA_BITS = 23;
            const int FLOAT_EXPONENT_BIAS = 127;

            // Reinterpret the float as an int (IEEE 754 binary32 format)
            int bits = Unsafe.As<float, int>(ref value);

            // Handle zero specially to avoid issues with denormals
            if (bits == 0)
                return 0;

            // Extract sign (1 bit)
            bool isNegative = (bits & 0x80000000) != 0;

            // Extract exponent (8 bits, biased)
            int exponent = ((bits >> FLOAT_MANTISSA_BITS) & 0xFF) - FLOAT_EXPONENT_BIAS;

            // Extract mantissa (23 bits, with implicit leading 1)
            int mantissa = (bits & 0x007FFFFF) | 0x00800000;

            // Compute the shift needed to align the mantissa to Q48.16
            int shift = (FLOAT_MANTISSA_BITS - Q16_SHIFT) - exponent;

            // Shift the mantissa into Q48.16 fixed-point
            long fixedPointValue;
            if (shift >= 0)
            {
                fixedPointValue = (long)mantissa >> shift;
            }
            else
            {
                // For left shifts, we need to handle potential overflow
                if (shift < -41) // More than 41 left shifts would overflow long
                {
                    fixedPointValue = isNegative ? long.MinValue : long.MaxValue;
                }
                else
                {
                    fixedPointValue = (long)mantissa << -shift;
                }
            }

            // Apply sign
            fixedPointValue = isNegative ? -fixedPointValue : fixedPointValue;

            return fixedPointValue;
        }

        private static long DoubleToRaw(double value)
        {
            const long Q16_SHIFT = 16; // 16 fractional bits (Q48.16 format)
            const long DOUBLE_MANTISSA_BITS = 52;
            const long DOUBLE_EXPONENT_BIAS = 1023;

            // Reinterpret the double as a long (IEEE 754 binary64 format)
            long bits = Unsafe.As<double, long>(ref value);

            // Handle zero specially to avoid issues with denormals
            if (bits == 0)
                return 0;

            // Extract sign (1 bit)
            bool isNegative = (bits & unchecked((long)0x8000000000000000)) != 0;

            // Extract exponent (11 bits, biased)
            long exponent = ((bits >> (int)DOUBLE_MANTISSA_BITS) & 0x7FF) - DOUBLE_EXPONENT_BIAS;

            // Extract mantissa (52 bits, with implicit leading 1)
            long mantissa = (bits & 0x000FFFFFFFFFFFFF) | 0x0010000000000000;

            // Compute the shift needed to align the mantissa to Q48.16
            long shift = (DOUBLE_MANTISSA_BITS - Q16_SHIFT) - exponent;

            // Shift the mantissa into Q48.16 fixed-point
            long fixedPointValue;
            if (shift >= 0)
                fixedPointValue = mantissa >> (int)shift;
            else
                fixedPointValue = mantissa << (int)(-shift);

            // Apply sign
            fixedPointValue = isNegative ? -fixedPointValue : fixedPointValue;

            return fixedPointValue;
        }
    }
}